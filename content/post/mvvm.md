---
title: "MVVM לעשות סדר בבלאגן"
summary: "
לפני כמה זמן הייתי צריך לקנות ארון לבית, הלכנו לחנויות של ארונות וראינו כל מיני עיצובים.

יש מלא, פשוט מלא.

אתה עובר, מסתכל על דלת הזזה כזאת, זו עם מראה, זו שחורה חלקה, וזו שקופה.

עכשיו מה העניין עם ארונות עם דלת שקופה? שהבגדים חייבים להיות תמיד מסודרים!

זה אולי נשמע קל, לסדר את הבגדים יפה בארון, אבל איכשהוא זה תמיד מתבלגן.

אתה מוציא חולצה אחת, וכל החולצות מקבלות פתאום צורה משל עצמן.

אז איך בכל זאת שומרים על הארון שלכם מסודר ומאורגן כמו בפרסומות?

משתמשים בכלים הנכונים!"
date: 2021-02-05T00:47:49+02:00
keywords: ["app architecture", "mvvm", "view model"]
tags: ["מתקדמים", "ארכיטקטורה"]
draft: false
---

<span>Photo by <a href="https://unsplash.com/@belart84?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Artem Beliaikin</a> on <a href="https://unsplash.com/s/photos/wardrobe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></span>

לפני כמה זמן הייתי צריך לקנות ארון לבית, הלכנו לחנויות של ארונות וראינו כל מיני עיצובים.

יש מלא, פשוט מלא.

אתה עובר, מסתכל על דלת הזזה כזאת, זו עם מראה, זו שחורה חלקה, וזו שקופה.

עכשיו מה העניין עם ארונות עם דלת שקופה? שהבגדים חייבים להיות תמיד מסודרים!

זה אולי נשמע קל, לסדר את הבגדים יפה בארון, אבל איכשהוא זה תמיד מתבלגן.

אתה מוציא חולצה אחת, וכל החולצות מקבלות פתאום צורה משל עצמן.

מהר מאוד הארון המדוגמן שראינו בפרסומת הופך מזה

<img src="https://media.architecturaldigest.com/photos/5e42d0cb2fd7a100093443da/2:1/w_1280%2Cc_limit/2019_Friedman_MStewart_Corp_HER_CLOSET_0850_PR.jpg" alt="nice" style="zoom:50%;" />

לזה.

<img src="https://treadingmyownpath.com/wp-content/uploads/2014/08/Closet-Hoarder.jpg" alt="blagan" style="zoom:50%;" />

זה כמובן לא קורה רק לארונות ולבגדים. זה קורה גם לקוד.

בקוד אפילו יש לנו שם מיוחד לזה, אנחנו קוראים לזה spaggeti code. קוד שנמשך כמו ספגטי, אתה מוחק משהו מפה ופתאום קוד במקום אחר מפסיק לעבוד.

אז איך בכל זאת שומרים על הארון שלכם מסודר ומאורגן כמו בפרסומות?

משתמשים בכלים שמכריחים אתכם לעבוד מסודר כמובן, כמו זה למשל.

<img src="https://ae01.alicdn.com/kf/HTB1CSKrXAP2gK0jSZPxq6ycQpXaS/10pc-T-shirt-Clothes-Closet-Organizer-Shirt-Folding-System-Board-Wardrobe-Storage-Rack-Cabinet-Organizer.jpg" alt="shirt oergeniser" style="zoom:33%;" />

ככה אנחנו יכולים להבטיח שהחולצות שלנו יישארו תמיד מסודרות, ויהיה לנו ארון מדוגמן.

גם בקוד, אנחנו יכולים לעשות אותו הדבר. בקוד אנחנו משתמשים ב**ארכיטקטורה** נכונה.

והיום נלמד על אחת מהארכיטקטורות הנפוצות והיעילות ביותר בפיתוח תוכנה לאנדרואיד, **MVVM**.

## אז מה זה בעצם MVVM?

**MVVM** אלו ראשי תיבות של 

- Model
- View
- ViewModel

והוא מתאר את שלושת חלוקות היסוד של הארכיטקטורה.

כלומר, שלושת הקטגוריות הראשיות שאליהן אנו מחלקים את הקוד שלנו.

כשאנחנו משתמשים בארכיטקטורה אנחנו לא פשוט כותבים קוד איפה שמתחשק לנו, אנחנו מקפידים לסדר את הקוד בצורה מסויימת.

החלוקה היא לא רק לקלאסים שונים, זה ברור. החלוקה מדברת על **תחומי ענין** שונים.

כל קלאס חייב לטפל רק בתחום העניין שלו. דברים ששייכים ל`model` יטופלו אך ורק במודל, דברים ששייכים ל`view` יטופלו אך ורק בview, וכן הלאה.

ההפרדה הזו מאפשרת לנו לבצע שינויים בקומפונננטה אחת בלי לפגוע באחרת.

היא גם מאפשרת לנו לסדר את הקוד שלנו ביחידות לוגיות ברורות ומובנות.

אז מה בעצם אומרת כל אחת מהקטגוריות האלו?

### Model

מודל מתאר למעשה את היחידה הבסיסית של מידע באפליקציה.

מה זה מידע?

מידע זה למשל רשימה של תמונות, או רשימה של בני אדם, או פרטי לוגין.

למידע יש מקור (source), ולמקור המידע אנחנו נקרא `data source`. 

יכולים להיות כמה data sources באפליקציה אחת. למשל, שרת API הוא data source אחד.

אם אנחנו שומרים את המידע על גבי דאטה בייס, זה יהיה data source נוסף. 

יכול להיות שהמידע שלנו מורכב ממידע שמתקבל מכמה data sources. 

ניתן דוגמה:

אם אנחנו נכנסים לאפליקציה של פייסבוק, אנחנו רואים את הפיד שלנו.

ממה הוא מורכב?

קודם כל הוא מורכב מפרטי היוזר שלנו, שם המשתמש שלנו, הסיסמה, רשימת חברים.

אחר כך הוא מורכב מרשימה של פוסטים.

כל פוסט מורכב מטקסט, ממספר לייקים, מתאריך, שם ורשימה של תגובות.

אם אנחנו כותבים תגובה, פייסבוק תשמור גם אותה, ותעלה אותה אחר כך לשרת כדי שמשתמשים אחרים יוכלו לראות אותה.

כלומר, data source הוא **דו-כיווני**, אפשר לקרוא ממנו ולכתוב אליו.

#### Repository

כדי לממש model בצורה נכונה, אנחנו נעשה אבסטרקציה לdata source, אחרי הכל למי שרוצה לקרוא את הdata, לא באמת חשוב מה המקור שלו.

ב`repository` אנחנו נדבר עם ה data source שלנו, ונחצין מתודות שיאפשרו לשכבות האחרות לתקשר איתו, מבלי לחשוף באיזה data source אנחנו משתמשים מאחורי הקלעים.

### View

טוב, החלק הזה די ברור. 

זה החלק שבו אנחנו מציירים על המסך, מראים ליוזר את מה שהוא רוצה לראות.

למשל בדוגמה של פייסבוק שהבאנו קודם, גם אם יש לנו את כל המידע על הפוסטים והפיד, זה לא שווה כלום אם אנחנו לא **מציגים** את זה למשתמש.

החלק של ה`view` הוא זה שאחראי על ה**אינטרקציה** עם המשתמש. זה אומר **להציג** לו את המידע, וזה גם אומר **לענות** לפעולות שלו עם המידע (למשל, להגיב ללחיצה על כפתור התגובה).

אבל איך המידע מגיע אל הview? 

ואיך האינטרקציה של היוזר בview משפיעה על המידע?

כאן אנחנו מגיעים לחלק הכי חשוב בארכיטקטורת MVVM, הViewModel.

### ViewModel

הview model הוא החוליה החסרה שלנו בפאזל.

הוא אחראי על ה**קישור** בין שכבת ה`model` לשכבת ה`view`.

הוא זה שאחראי לפנות ל`repository` ולבקש ממנו מידע.

הוא זה שיודע מה לעשות עם המידע כשה`view` מעדכן אותו שהיוזר לחץ על כפתור התגובה.

והוא זה שיעדכן את ה`view` כשיש `model` חדש לעבוד איתו.

## סדר הפעולות

אבל שימו לב, יש סדר פעולות מאוד ברור ומוגדר פה. 

הView מכיר את הViewModel ואותו בלבד.

הViewModel מכיר את הModel ואותו בלבד.

הModel מכיר אך ורק את עצמו.

מה זה אומר? זה אומר למשל שבשום פנים ואופן הViewModel לא משנה את הView.

למעשה הוא אפילו לא יודע מי זה הView, הוא מעולם לא משוחח איתו ישירות.

הView הוא זה שמשוחח עם הViewModel, רק הוא ואין בלתו.

הכלל הזה נכון גם לגבי הViewModel, הRepository לא מכיר את הViewModel, אין לו שום דיבור איתו, הViewModel והוא בלבד משוחח עם הRepository.

ההפרדה הזו **מאוד** חשובה, ואסור להפר אותה. בשום פנים לא נעביר אחריות בין הקומפוננטות השונות.

כשנרצה לכתוב פונקציה, תמיד נשאל את עצמנו תחת איזה קטגוריה היא נופלת, ונכתוב אותה במקום הנכון.

## Observables

אז איך בעצם מתבצעת העברת המידע בין הקומפוננטות השונות?

אם אמרנו שה`repository` לא מכיר את ה`ViewModel`, איך הוא ידע לעדכן אותו שהוא הוריד מידע חדש?

החלק האחרון של ארכיטקטורת MVVM הוא ה`Observable`.

הדבק שמחבר בין כל הקומפוננטות השונות.

אם אי אפשר שקומפוננטה אחת תדבר ישירות עם השניה, היא תדבר במקום זה עם Observable.

דמיינו שיש לכם רדיו. איך עובד רדיו בעצם? בתחנה יושבים שדרנים ומשדרים, הם לא יודעים למי הם משדרים, הם רק יודעים שהם משדרים.

לכם בבית יש מכשיר רדיו, כזה שמסוגל לקלוט את התדרים השונים.

אתם נרשמים לאחד התדרים, ומתחילים להאזין, ברגע שהשדרן יעדכן משהו, זה יגיע אליכם.

אבל זה לא יגיע אליכם כי השדרן יודע מי אתם ושידר אליכם ישירות, הוא פשוט שידר לאוויר, ואתם קלטתם את זה.

`Observable` עובד בדיוק כמו הרדיו. 

ה`Repository` יחזיק קלאס מסוג Observable, בכל פעם שיש לו משהו חדש לעדכן, הוא יעדכן את הObservable. 

ה`ViewModel` מאזין לאותו Observable, וברגע שהוא יקבל עדכונים, הוא יעדכן את המידע אצלו.

ואיך ה`View` יקבל את המידע הזה?

טוב, תוכלו כבר לנחש. גם ה`ViewModel` מחזיק `Observable` , וגם הוא יעדכן את הObservable שלו ברגע שיש משהו לעדכן.

ה`View` מאזין ל`Observable` של ה`ViewModel` ויעדכן את מה שהמשתמש רואה ברגע שה`Observable` יקבל עדכון.

בצורה הזו, ה`Repository` לא מכיר את ה`ViewModel` וה`ViewModel` לא מכיר את ה`View`, ובכל זאת המידע עובר ביניהם בצורה יעילה ואמינה.
