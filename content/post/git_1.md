---
title: "מה זה לעזאזל גיט? (או הפרק על חללית הבריאה)"
summary: "אם אתם עובדים על קוד, אתם חייבים להכיר את גיט. זה ידע מציל חיים וסטנדרט בתעשיה. אבל זה גם קונספט שעשוי להיות מסובך ולא מאוד אינטואיטיבי בהתחלה. פה אני מנסה לתאר את גיט כחללית שצופה ועוקבת אחרי אירועים בכוכבים שונים וגם יכולה לעשות חיבור ביניהם. נשמע מגניב? אתם לא מבינים עד כמה"
date: 2020-01-10T09:22:32+02:00
tags: ["מדריכים", "גיט"]
draft: false
---

אם אתם בתעשייה בערך יום, בטח שמעתם על גיט (git). 

זה מופיע במודעות הדרושים של כל החברות בערך, זה מופיע במדריכים אונליין, ובגדול כמעט ואין חברה שלא עובדת עם גיט (יש כאלה שעובדות על מערכות דומות).

אז גיט זו מערכת לניהול גרסאות. מה זה אומר? למה צריכים את זה? ואיך מתחילים?

פרק מתוך [הספר](/post/aboutme_post/#למה-בכלל-צריך-בעברית). 

## מי לעזאזל צריך ניהול גרסאות?

אז מגניב, כתבתם אפליקציה מדהימה, העלתם אותה לחנות, אתם מתחילים כבר לראות הורדות וזה פשוט כיף. 

אתם מחליטים להתחיל לפתח לה פיצ'ר חדש. אתם מתחילים לעבוד על הפיצ'ר, מוסיפים מסכים, משנים קריאות. מרגש. 

תוך כדי עבודה אתם מתחילים לקבל דיווחים שיש קריסה באפליקציה שבלייב (שבחנות). פאק. מה עושים עכשיו?! אתם לא יכולים לתקן ולהעלות כי הפיצ'ר עדיין בפיתוח וזה ייראה ממש על הפנים כרגע, אבל אם תחכו עד שתסיימו את הפיצ'ר זה יקח לפחות שבוע, בינתיים המשתמשים שלכם עוזבים אתכם וכותבים לכם תגובות רעות, הדירוג שלכם יורד וזה שיט, בדיוק כשסיימתם לעשות seo מדהים וגרף ההורדות שלכם התחיל לעלות. 

אם רק הייתה דרך לחזור לנקודה שבה שיחררתם את הגרסה, לתקן רק את הבאג ולהעלות מחדש לחנות. 

רגע, אולי בעצם יש! 

אתם יכולים פשוט לשמור את תיקיית הפרוייקט לפני העלאה לחנות. להעתיק אותה ולקרוא לה למשל `app_v_1`. 
ואז להמשיך לעבוד על התיקייה המקורית ולפתח שם את הפיצ'ר. 
אם יתעורר צורך, תוכלו פשוט לחזור לתיקיית הגיבוי לערוך שם את התיקון, וזהו, שום דבר לא נשבר. יאיי!!

![Imgur](https://i.imgur.com/jEWqdLZ.png)

רק שכמובן צריך לעשות את התיקון גם בתיקייה המקורית. כן. טוב סבבה, לא ביגי, זה תיקון של חמש שורות, נעתיק אותו מפה ויהיה בסדר. 

אוי לא, אבל זה אותו קובץ ששיניתם בתיקייה המקורית בשביל הפיצ'ר החדש. אי אפשר פשוט לדרוס אותו. טוב, נצטרך לעבור ידנית ולתקן גם בתיקייה המקורית. 

אבל מה אם שינינו שני קבצים? או שלושה? נעבור ידנית אחד אחד ונעתיק שינויים מפה לשם? זה יקח ים זמן! 

חוץ מזה שבשלב מסוים יהיו לנו כל כך הרבה תיקיות, איך נדע מה כל תיקייה מכילה? נצטרך לתת שמות ממש ארוכים לכל תיקייה משהו כמו `app_v1_with_null_crash_fix` 

אני יודע מה אני צריך, אני צריך דרך להשוות בין כל הקבצים. אני אראה אותם אחד מול השני, אראה בדיוק מה השינויים ואחליט איזה שינויים צריכים להיכנס לקוד המאוחד. 

נהדר! הו ואם יש דרך להציג רק את השינויים כדי שאני לא אצטרך לעבור על כל הקובץ רק בשביל לשנות שורה אחת. 

בעצם, למה שהוא לא יעשה את זה בשבילי אוטומטית? שיקח את הקוד החדש שלי ויעתיק אותו לתיקייה העכשווית. כן, זה יהיה נפלא. 

אתם כבר יודעים מה יקרה עכשיו, נכון? מה יקרה אם עשיתם שינוי גם בתיקייה העכשווית (`app`) וגם בתיקיית הגיבוי (`app_v_1`)?

למשל בקובץ המקורי הייתה הפונקציה הבאה

```java
private String whatIsGit() {
  return null;
}
```

ובעבודה על הפיצ׳ר (כלומר בתיקייה העכשווית) שיניתם אותו לקוד הבא

```java
private String whatIsGit() {
	return "git is an awsome way to manage versions";
}
```

אבל בתיקיית הגיבוי הייתה לכם קריסה כי למה לעזאזל אתם מחזירים null? לא לימדתי אתכם כלום בפרקים הקודמים?!! אז שיניתם את זה לקוד הבא

```java
private String whatIsGit() {
	return "";
}
```

רגע, עכשיו מה הכלי האוטומטי יעשה? איזה שינוי הוא יקח?

נוצר פה בעצם קונפליקט, נכון? אוקיי, אז בואו נגיד שהכלי האוטומטי יאחד בין קבצים רק אם אין בהם קונפליקטים. ובמקרה של קונפליקט הוא יציג לנו את שני הקבצים אחד מול השני ויבקש מאיתנו לבחור איזה שינוי יעבור לקובץ המאוחד, אם בכלל. 

זה יעבוד.

אז בואו נסכם, מה אנחנו רוצים? 

- -להקפיא קבצים בקפסולת זמן
- -להיות מסוגלים לחזור לקפסולה הזאת ולבצע שינויים בלי שזה ישפיע על הקבצים הנוכחיים שלנו
- -לאחד בין קפסולות שונות בלי לדרוס אחת את השניה
- -לצפות בכל הקפסולות ולראות בקלות מה השינויים שנעשו בהם
- -להשוות בין אותם קבצים שמאוחסנים בקפסולה לקבצים הנוכחיים שלנו, ולבחור איזה שינויים לקבל משם 

הכלי הדמיוני שלנו נשמע ממש מדהים, כל כך מדהים שבטוח היה מישהו שחשב עליו קודם.

ובכן כן, היה מישהו, למעשה כמה מישהואים. הקונספט הזה נקרא [version control](https://en.wikipedia.org/wiki/Version_control) או בעברית ״ניהול גרסאות״.

יש כמה שיטות של ניהול גרסאות, אך הפופולרית וזו שכנראה תעבדו איתה בתעשיה היא [git](https://git-scm.com/).

## git

גיט פותחה בשנת 2005 ע״י [לינוס טורוואלדס](https://github.com/torvalds), האב המייסד של של מערכת ההפעלה [לינוקס](https://www.linux.org/).

<img src="http://bit.ly/2R0wzhX" alt="linus torvalds" style="zoom:33%;" />

לינוקס מפותחת בקוד פתוח, כלומר כל מפתח (גם אתם) יכול לתרום לשם קוד. זה מאפשר שיתוף פעולה רחב של מאות ואולי אפילו עשרות אלפי מתכנתים על אותו פרוייקט.

בגדול זה נשמע נהדר, אבל תוך כדי עבודה על הליבה של לינוקס, לינוס גילה שזה ממש קשה לנהל פרוייקט שכל העולם בערך עובד עליו ביחד.

לינוס רצה מערכת ניהול גרסאות שתהיה 

- מהירה
- פשוטה
- תאפשר לנהל פרוייקטים ענקיים בקלות
- תהיה מבוזרת (כלומר בלי צורך בשליטה מרכזית)

אז הוא יצר את גיט.

### מה זה גיט?

תחשבו על גיט כעל יקום, יקום שמורכב מרצף של אירועים.

כל אירוע הוא בעצם קפסולת זמן, נקודה מסויימת בחיי היקום. ויש לו מספר סידורי מיוחד, שמייצג אך ורק אותו.

לכם יש חללית על שיודעת לנווט ולשלוט ברצף האירועים של היקום.

אבל היקום שלכם נורא גדול ומורכב מהמון כוכבים, כל כוכב יודע להסתכל על חלק מהרצף, ואפילו להוסיף אירועים לרצף שכוכב אחר כלל לא יהיה מודע אליהם.

החללית שלכם יכולה גם לשנות את רצף האירועים, היא יכולה לשנות חלק משמות הכוכבים, לייצר כוכבים חדשים שיהיו העתק מדוייק של כוכבים קיימים, למחוק אירועים, לשנות את הסדר של הרצף , למחוק לחלוטין כוכב מסויים, וגם להעתיק אירועים מכוכב אחד לאחר, או לאחד בין האירועים של שני כוכבים.

<img src="https://i.imgur.com/zvoJPcC.png" alt="mars" style="zoom:50%;" />

נניח והיה לנו כוכב בשם ארץ, בשלב מסויים שמרנו את השינויים שנעשו בו בקפסולת זמן, והוספנו אירוע בשם ״אוקיינוסים נוצרו״. האירוע קיבל את הייצוג הייחודי `001` .

בחלוף הזמן שמרנו את השינויים שקרו מאז בקפסולת זמן נוספת והוספנו אירוע חדש בשם ״מתחילים חיים במים״. האירוע הזה קיבל את הייצוג הייחודי `002`.

מגניב!

כעת ארץ מצביע על אירוע `002`, ומכיון שאירוע `002` מבוסס על אירוע `001`, שניהם קיימים בכוכב ארץ.

מעולה. עכשיו החלטנו להעתיק את כוכב הלכת ארץ, וליצור כוכב חדש לו קראנו ״מאדים״ - שם יצירתי, אהבתי!

בהתחלה כשרק יצרנו אותו גם מאדים הצביע על אירוע `002`, אבל במאדים קרו שינויים חדשים שלא קרו בארץ, ואנחנו החלטנו לשמור אותם בקפסולת זמן חדשה ולשמור את האירוע ״אפקט חממה נוצר״. האירוע החדש קיבל את הייצוג הייחודי `003`. 

שימו לב עכשיו, ארץ עדיין מצביע על אירוע `002`, ומי שיבקר בארץ לא יראה שום אפקט חממה, זאת מכיון שרק מאדים מצביע על אירוע `003`.

אבל נגיד שאנחנו נורא מרוצים מאפקט החממה ורוצים להעתיק אותו גם לארץ. זו לא בעיה, רק נגיד לחללית שלנו לאחד את מאדים שוב עם ארץ ואז שניהם יצביעו על אירוע `003`.

מה שלא ידענו זה, שבזמן שאנחנו טיילנו על הכוכב האדום, בארץ כבר הספיקו להיכנס שינויים חדשים. מישהו (לא חשוב שמות) יצר שם קפסולת זמן חדשה, והוסיף לה את האירוע ״נוצרו בני אדם״, ובני אדם ואפקט חממה לא מסתדרים כל כך טוב.

<img src="https://i.imgur.com/4uWfmpk.png" alt="people on earth" style="zoom:50%;" />

החללית שלנו לא מוכנה לבצע את האיחוד, היא מודיעה על קונפליקט, ודורשת מאיתנו לסדר אותו לפני שנמשיך באיחוד, או שנבטל אותו.

אנחנו מתבוננים בשני האירועים, מוחקים קצת כאן ומעתיקים קצת שם ועכשיו יש לנו אירוע איחוד מרגש!

אנחנו שומרים את השינויים בקפסולת זמן חדשה ויוצרים אירוע בשם ״מחזור המים״. האירוע הזה קיבל את המזהה הייחודי `005`

<img src="https://i.imgur.com/f1rUpOY.png" alt="earth water" style="zoom:50%;" />

עכשיו ארץ מצביע על האירוע המאוחד והחדש שלנו `005`, ומאדים (שלא מכיר את האירוע נוצרו בני אדם) עדיין מצביע על אירוע `003`.

אוקיי, עכשיו בואו ננחת חזרה במחשב שלנו, ונתחיל להשתמש בגיט, אבל באמת.

## התקנה

### התקנה על ווינדוס

ההתקנה על ווינדוס די פשוטה, אתם צריכים להוריד את קובץ ההתקנה [מהאתר](https://git-scm.com/), ופשוט לעקוב אחרי ההוראות עד לסיום ההתקנה.

אם בכל זאת אתם מעדיפים עזרה, הנה סרטון יוטיוב שמסביר את זה יפה (אתם צריכים לצפות עד דקה 3, את מה שהוא מראה אחר כך נלמד פה בהמשך המדריך)

https://www.youtube.com/watch?v=MmSCmHClEEk

### התקנה על מק

במק זה הרבה יותר קל, פתחו את הterminal והקלידו

```bash
git --version
```

אם זה לא מותקן לכם כבר, אתם תקבלו הודעה שתבקש מכם להתקין את גיט על המחשב, לחצו install והמשיכו לפי ההוראות.

### הגדרת משתמש

לאחר ההתקנה יש לעדכן את גיט בפרטי המשתמש שלכם. הפרטים האלה יופיעו יחד עם ההודעות שלכם, כך שכל מי שמסתכל על ההיסטוריה בגיט ידע מי ביצע איזה שינוי.

פתחו את שורת הפקודה (CMD בווינדוס או terminal במק) וכתבו את השורות הבאות

```bash
git config --global user.name "Margalit Tsanani"

git config --global user.email "margol_hamalka@gmail.com"
```

כמובן שאתם צריכים להחליף את השדות במרכאות בפרטים האמיתיים שלכם. 

זהו, עכשיו אנחנו מוכנים, בואו נתחיל

### repository (יקום)

כל פרוייקט בגיט מתחיל בריפו (קיצור מקובל למילה repository) 

התרגום המילולי הוא **מאגר**, וזה בעצם אומר התיקייה הראשית של הפרוייקט שלכם.

אז בואו ניצור תיקייה.

נפתח את שורת הפקודה ונכתוב

```bash
mkdir git_lesson_01 && cd git_lesson_01
```

 עכשיו כשאנחנו בתוך התיקייה בואו נהפוך אותה לריפו

```bash
git init
```

בהנחה וגיט מותקן לנו על המחשב בהצלחה, אנחנו אמורים לקבל את ההודעה הבאה

```bash
Initialized empty Git repository in /Users/orelzion/git/book_projects/git_lesson_01/.git/
```

עכשיו בואו ניצור קובץ ונכתוב בו קצת טקסט

```bash
touch README.md
```

פתחו את הקובץ שנוצר בעורך הטקסט החביב עליכם, ומלאו אותו בטקסט, איזה טקסט שבא לכם. אני רשמתי בו

```
First lesson in git!! Yay
```

כעת בואו נחזור לשורת הפקודה ונקליד את הפקודה הבאה

```bash
git status
```

אם עשינו הכל נכון, נקבל את התשובה הבאה

```bash
On branch master

No commits yet

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	README.md

nothing added to commit but untracked files present (use "git add" to track)
```

אוקיי, בשלב הזה אתם די רוצים לזרוק עלי איזה עט או משהו (שלא יכנסו לכם רעיונות לראש, כן? לא להרוג את השליח)

מה? מה לעזאזל כתוב פה בכלל?

אז רגע, שוויה שוויה. יש כאן הרבה מונחים חדשים שאנחנו לא מכירים, ואני כמובן הולך להתעלם מהם, כי כבר שילמתם על הספר אז מה אכפת לי עכשיו?

לא, סתם סתם. אנחנו נלמד הכל, לא לדאוג.

בואו נתחיל מזה שגיט אומר לנו שדווקא יש כאן קובץ, כלומר הוא מזהה את הקובץ החדש שיצרנו, אבל הוא אומר שהוא untracked, כלומר גיט לא מתכוון לעקוב אחריו, או לשמור אותו.

יופי אוראל, תודה רבה. מאוד עוזר!

![great succes](https://i.imgur.com/XJyemeI.jpg)

אז בואו נתחיל בלהוסיף את הקובץ לרשימת המעקב של גיט. זה די קל למעשה

```bash
git add README.md
```

עכשיו כשנריץ את `git status` נקבל את התשובה הבאה

```bash
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

new file:   README.md
```

עכשיו הוא לא רק מזהה את הקובץ שיצרנו, אלא אפילו יודע שהוא קובץ חדש! זה מעולה, זאת אומרת שהוא מבחין שנעשה כאן שינוי.

אבל זה עדיין לא אומר שהשינוי הזה נרשם להיסטוריה של גיט.

כדי ״להקפיא״ שינוי וליצור למעשה רשומה חדשה בהיסטוריה של גיט, אנחנו צריכים לבצע commit

{{<subscribe text="אל תפספסו את החלק הבא!">}}

### commit (אירוע)

<img src="https://devrant.com/rants/317195/image.png" alt="git commit" style="zoom:50%;" />

commit זו פקודת הגיט הכי בסיסית ונפוצה. למעשה הפקודה הזו מקפיאה את השינויים שלנו ויוצרת רשומה חדשה בהיסטוריה של הריפו.

כל קומיט יוצר מאחורי הקלעים גיבוי מלא של כל הקבצים שלנו (בהנחה וזכרנו לעשות להם `add`), ושומר אותם בצד. 

גיט קומיט זה האירוע שחותם את קפסולת הזמן שלנו בדוגמת החללית.

לכל קומיט חייבת להתלוות הערה, הסבר על משמעות השינוי. גיט לא יתן לכם לעשות קומיט בלי הערה, אבל אף אחד לא יכול למנוע מכם לכתוב שם שטויות. 

הכרתי מתכנת אחד, שהיה גאון בתחומו, אבל בגיט? ובכן... כל פעם שהוא היה עושה קומיט הוא פשוט היה רושם בהערה `commit`. זה כמובן חסר משמעות לחלוטין. 

תחשבו שאתם נכנסים לארכיון המדינה, אתם מחפשים את עיתון ״דבר״ שיצא לאור בשני לספטמבר 1957. יש לכם תאריכים, אבל על כל תיקייה יש מדבקה שעליה רשום ״עיתון״. זה כמובן ידרוש מכם לפתוח כל תיקייה ולבדוק איזה עיתון יש בה, מה שמייתר לחלוטין את הדבקת המדבקה מלכתחילה. 

בקוד זה עוד יותר בעייתי. זוכרים שאמרנו שלפעמים אנחנו רוצים לבדוק למה שינוי מסוים נכנס בקבוץ מסוים? אם יש לנו הערה מפורטת, יהיה לנו קל מאוד להבין, אבל אם תהיה רשומה הערה כללית - אנחנו לא נבין מזה כלום.

אוקיי, אז איך עושים את זה?

```bash
git commit -m 'added read me file'
```

אז `git commit` אתם מבינים. מה שמגיע אחרי זה זו ההערה. לפני ההערה אנחנו נשים תג m- שזה למעשה קיצור של message, ואחרי התג נכתוב את ההערה עצמה בתוך גרשיים. 

זו התשובה שנקבל

```bash
[master (root-commit) 8c70d30] added read me file
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
```

נתעלם כעת משתי המילים הראשונות ונעבור לדבר המוזר הזה שנראה כמו סיסמה לא זכירה בעליל. `8c70d30` ? מה? ובכן, זה המזהה של הקומיט שלכם. בעגה המקצועית ה״האש״ (hash) של הקומיט שלכם.

(מה זה בדיוק האש ואיך משתמשים בו? תוכלו ללמוד על כך בסרטון המעולה הזה https://youtu.be/2BldESGZKB8)

המזהה הזה הוא ייחודי לקומיט הזה, אין עוד קומיט בעולם שנושא את אותו האש. זה מאפשר לגיט להבדיל אותו מכל קפסולה אחרת, ולחזור אליו במקרה הצורך במהירות. 

אחרי ההאש, מגיעה ההערה שלנו.

מתחתיה תיאור של הקומיט, מה השינוי שנעשה.

גיט מדווח לנו שהקומיט שעשינו גרם ליצירה של קובץ חדש 1, ושל הוספת טקסט אחת (בתוך אותו קובץ). 

השורה האחרונה פחות מעניינת, גיט פשוט מרחיב ומספר לנו איך הוא יצר את הקובץ במערכת. כל הכבוד גיט! אתה מלך! סבבה. כאילו יצרת קובץ, בא, זה לא שכתבת את הקוד, אבל בסדר.

נעשה עוד אחד עכשיו? יאללה!

נפתח את הקובץ שיצרנו ונשנה בו משהו. תוסיפו אות, תמחקו משהו, מה שבא לכם. תשמרו ותסגרו. ובואו נחזור לשורת הפקודה ונכתוב

```bash
git commit -m 'changed text in read me file'
```

הנה התשובה שנקבל

```bash
On branch master
Changes not staged for commit:
	modified:   README.md

no changes added to commit
```

אה, מה? אני לא מבין מה קורה פה. אז גיט מבין ששינינו את הקובץ אבל עדיין כותב שאין שינויים להוסיף לקומיט. איך זה יכול להיות?

טוב, זוכרים קודם שהיינו צריכים לקרוא ל `git add` כדי שיזהה הוספה של קובץ חדש? אוקיי, אז זה לא רק קובץ חדש.  גיט הוא כלי מאוד זהיר, הוא לא יעשה כלום אם לא נגיד לו במפורש לעשות זאת. גם אם הוא יודע שעשינו שינויים הוא לא יתייחס אליהם אם לא נאמר לו שזה מה שאנחנו רוצים לעשות. 

הפעולה של הוספת שינוי לגיט נקראת **staging**. והיא מתבצעת, נכון, על ידי קריאה ל

```bash
git add README.md
```

אבל **שימו לב!** `staging` לא אומר שהוספנו את השינוי לקפסולה, זה רק אומר שאנחנו מתכוונים לעשות זאת. כלומר שבזמן שנקרא ל`commit`, אנחנו רוצים שהשינוי הזה יהיה שם. כל עוד לא קראנו לקומיט, השינוי הזה רק מופיע ברשימת ״המועמדים לשימור״, אבל הוא עוד לא חלק מקפסולת הזמן.

עכשיו, אחרי שהוספנו אותו לstaging, אנחנו יכולים לקרוא שוב לקומיט

```bash
git commit -m 'changed text in read me file'
```

ועכשיו זה גם יעבוד. הנה התשובה שלנו

```bash
[master 8b74757] changed text in read me file
 1 file changed, 1 insertion(+), 1 deletion(-)
```

מגניב לא? אבל קצת ארוך. אם כל פעם שנעשה שינוי נצטרך לקרוא `git add` על כל קובץ, אנחנו נחטוף בעיקר כאב ראש. 

היינו רוצים לקרוא ל `git add` רק אם הוספנו קובץ, ושאת כל הקבצים שכבר הוספנו הוא יוסיף לבד לקומיט, נכון? או במילים אחרות אנחנו רוצים שבזמן קומיט יתרחש staging אוטומטי.

איזה כיף לדעת שיש לנו בדיוק את זה.

בואו נפתח שוב את הקובץ ונעשה עוד שינוי.

אבל עכשיו כשנעשה קומיט, ההודעה תהיה שונה במקצת.

```bash
git commit -am 'changed text in read me file'
```

שמתם לב להבדל? מי ששם לב מקבל חמש נקודות, לכו קנו לעצמכם איזה מגנום או משהו. 

כן, השינוי הוא כל כך קטן, אבל כל כך משמעותי. במקום להקדים את ההודעה עם התג `m-` אנחנו מקדימים עם `am-`. ה`m` עדיין מייצג את ההודעה, אבל ה`a` הוא למעשה קיצור של שני מילים `add all`. וזהו! זה כל הקסם. לא צריכים להוסיף כל קובץ בנפרד, כל הקבצים שבהם נעשו שינויים יתווספו לקומיט שלנו. 

**שימו לב!** זה נכון רק לקבצים שכבר קיימים בגיט, אם הוספנו קובץ חדש עדיין נצטרך לקרוא ל `git add` כדי להוסיף אותו לstaging, גיט לא ידע לעשות את זה באופן אוטומטי, כי הוא לא יודע אם אנחנו רוצים את הקובץ הזה שם, או שהוא סתם משהו זמני שלנו.

## המשך יבוא

טוב, אז זה היה חלק מתוך הפרק על גיט בספר, החלק הבא יתפרסם בהמשך.

בינתיים, אשמח מאוד אם תכתבו לי בתגובות אם אהבתם, מה אתם חושבים שכדאי לשפר והאם זה עזר לכם.

ואל תשכחו להירשם לקבלת עדכונים! כדי שלא תפספסו את החלק הבא