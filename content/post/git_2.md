---
title: "מה זה לעזאזל גיט? פרק שני"
summary: "אחרי שבפרק הקודים למדנו את המונחים הבסיסיים בגיט, איך לשמור שינויים ואיך יוצרים ריפו. בפרק הנוכחי נלמד איך יוצרים ועוברים בין בראנצ׳ים, וגם איך עובדים בצוות ומול שרת מרוחק. היכולת להעלות את הקוד שלנו לשרת מרוחק היא קריטית, גם כדי שנוכל לעבוד כצוות בו מפתחת אחת לא דורכת על הקוד של מפתח אחר ושניהם יכולים להתקדם במקביל, וגם בשביל שתוכלו לפרסם את הקוד שלכם איפה שהמעסיקים יכולים לקרוא אותו. אז למה אתם מחכים? יאללה - פרק ב׳"
date: 2020-02-05T20:03:32+02:00
tags: ["מדריכים", "גיט"]
draft: false
---

### branch (כוכב)

אוקיי, אז אנחנו יודעים איך להוסיף קבצים לstaging (מועמדים לשימור), ואנחנו יודעים איך לבצע שמירה לקפסולות זמן (commit). 
אבל איך אני יכול לעבור בקלות בין קפסולות כאלה? 

אם אתה זוכרים בדוגמה הידנית שלנו יצרנו תיקיית גיבוי, כך שכל שינוי שנעשה בתיקייה העכשווית שלנו לא יופיע בכלל בתיקיית הגיבוי. 
האם זה אפשרי בגיט? כן. 

בדוגמת החללית שלנו יצרנו כוכבים, בגיט זה מכונה branch או ענף. כל ענף כזה מצביע בעצם על קומיט מסוים.

בכל פעם שאנחנו רוצים להתחיל לעבוד על פיצ'ר מסוים, אנחנו פותחים branch חדש ונותנים לו שם שמלמד על הפיצ'ר. למשל `feature/new_git_capability`. הבראנץ' הזה מצביע כעת על הקומיט האחרון שממנו פתחתם את הבראץ'. 

למעשה, אין דבר כזה לעבוד בגיט בלי להיות על בראנץ' מסוים. בפעם הראשונה שעשינו `git init` גיט יצר עבורנו בראנץ' באופן אוטומטי. הבראנץ' הזה נקרא `master` והוא קיים תמיד בכל גיט ריפו, כי הוא נוצר אוטומטית כשמאתחלים ריפו. 

כאשר יש לנו בראנצ'ים אפשר לעבוד בלי להשפיע בכלל על הבראנץ' האחר. כך למשל אם פתחנו בראנץ' `feature/cool_feature` נוכל לפתח עליו ואפילו לעשות עליו קומיטים, ומי שיבדוק את הבראנץ' `master` בכלל לא יראה שהם קיימים!

יותר מדי דיבורים, בואו נפתח את שורת הפקודה ונקליד את הפקודה הבאה

```bash
git status
```

בכל פעם שאתם רוצים לבדוק באיזה בראנץ׳ אתם, מה מצב הקבצים בריפו שלכם, האם יש לכם קבצים בstaged? קבצים חדשים שעדיין לא בstaged? אתם קוראים ל `git status`.

זו התשובה שנקבל

```bash
On branch master
nothing to commit, working tree clean
```

נהדר. עכשיו אנחנו רוצים לעשות שינויים שלא ישפיעו על `master`. כלומר, אנחנו רוצים לפתוח branch חדש. 

איך עושים זאת?

```bash
git branch feature/branch_lesson
```

אוקיי, יצרנו branch חדש וקראנו לו `feature/branch_lesson`הקידומת `feature` לא הכרחית כאן, אתם יכולים לקרוא לו באיזה שם שאתם רוצים, אבל זה יוצר יותר סדר, שמות - עוד תלמדו בהמשך - מאוד חשובים אחר כך כשתרצו לעבור בין בראנצ׳ים ותצטרכו להבין איזה branch אתם בעצם צריכים.

מעולה. עכשיו בואו נריץ שוב את

```bash
git status
```

ונקבל את התשובה הבאה:

```bash
On branch master
nothing to commit, working tree clean
```

מעולה. כלומר, לא מעולה. מה זה? איפה הבראנץ׳ שהרגע יצרנו?!

שאלה נהדרת! אז קודם כל תירגעו, הוא שם. איך אני יודע? תריצו את הפקודה הבאה

```bash
git show-branch --list
```

וזו התשובה שנקבל

```bash
  [feature/git_branch_lesson] changed text in read me file
* [master] changed text in read me file
```

מה שמופיע בסוגריים זה שם הברנץ׳, ואחריו הודעת הקומיט האחרונה שרשומה בו.

שמים לב לכוכבית ליד השורה של `master`? היא מסמנת שמסטר הוא הבראנץ׳ הנוכחי שלנו.

אוקיי, אז הבראנץ׳ שיצרנו בהחלט קיים בריפו שלנו, איך אנחנו עוברים אליו? 

כדי לעבור בין בראנצ׳ים, אנחנו משתמשים בפקודה `checkout`, כמו בעצם צ׳ק אין וצ׳ק אווט שעושים במלון. אנחנו בעצם עוזבים את הבראנץ׳ הנוכחי שלנו ועוברים לבראנץ׳ אחר.

```bash
git checkout feature/git_branch_lesson
```

וזו התשובה שנקבל

```bash
Switched to branch 'feature/git_branch_lesson'
```

מעולה!

אם נריץ עכשיו שוב את

```bash
git show-branch --list
```

נראה את התשובה הבאה

```bash
* [feature/git_branch_lesson] changed text in read me file
  [master] changed text in read me file
```

אותה רשימה כמו קודם, רק שעכשיו הכוכבית נמצאת ליד הבראנץ׳ החדש שלנו. יאיי!

**שימו לב!** עוברים בין בראנצ׳ים רק אחרי שסיימנו לעשות קומיט לשינויים שלנו! בשום אופן לא נעבור בין בראנצ׳ים או ניצור בראנץ׳ חדש אם לא שמרנו את השינויים שלנו, על ידי העברתם ל stage וביצוע commit. 

כדי להיות בטוחים שאתם יכולים לעבור לבראנץ׳ חדש קראו קודם ל `git status` וודאו שאין לכם קבצים לא שמורים.

<img src="https://devrant.com/rants/1256455/image.png" alt="names are important" style="zoom:50%;" />

שמות זה חשוב :) 

#### שינויים בין בראנצ׳ים

עכשיו שאנחנו על בארנץ׳ שונה, בואו נעשה שינוי בקבצים שלנו ונראה איך השינוי קורה רק בתוך הבראנץ׳ שלנו, ולא משפיע על `master`.

פתחו את הקובץ `README.md` ושנו את הטקסט שבו למשהו חדש. למשל `we are now on a new branch`.

כעת, בואו נשמור את השינויים ונבצע `commit`.

```bash
git commit -am 'feat: new branch, new text'
```

וזו התשובה שנקבל

```bash
[feature/git_branch_lesson 70667ad] feat: new branch, new text
 1 file changed, 1 insertion(+), 1 deletion(-)
```

זוכרים שאמרנו שנחזור לעניין הסוגריים בהמשך? טוב, אז עכשיו אתם כבר יודעים מה זה, נכון? זה השם של הבראנץ׳ כמובן, ולידו ההאש של הקומיט. 

אחרי הסוגריים מופיעה ההודעה של הקומיט שלנו, ומתחתיה מהות השינוי.

מקסים!

עכשיו בואו נריץ שוב את הפקודה הבאה

```bash
git show-branch --list
```

ו...

```bash
* [feature/git_branch_lesson] feat: new branch, new text
  [master] changed text in read me file
```

הופה! שמים לב? 

מאסטר עדיין מכוון על הקומיט האחרון שעשינו בו, ואילו הקומיט הנוכחי שלנו קיים רק על הבראנץ׳ החדש שלנו. זה מקסים!

אני רוצה עכשיו שנחזור ל`master` ונבדוק איך נראה הקובץ שלנו שם.

זוכרים איך עושים את זה?

```bash
git checkout master
```

מעולה!

עכשיו בואו נפתח את הקובץ `README.md`. ושימו לב! הטקסט המקורי נשמר שם!

```
First lesson in git!! Yay
```

### remote

<img src="https://devrant.com/rants/1503964/image.png" alt="backup" style="zoom:50%;" />

כל מה שדיברנו עליו עד עכשיו עבד מקומית על המחשב שלנו. אבל בדרך כלל אנחנו נרצה לעבוד גם מול שרת מרוחק.

יש לכך כמה סיבות

1. כדי שתמיד יהיה לנו גיבוי של הפרוייקט והבראנצ׳ים השונים שלנו
2. כדי שנוכל לשתף קוד עם אחרים

בדרך כלל בעבודה נצטרך לעבוד עם עוד אנשים ונרצה את היכולת לשתף ביננו את הפרוייקט או את הריפו.

כדי שזה יוכל לקרות אנחנו צריכים שכל הריפו שלנו יישב על מחשב מרכזי אחד, שאנחנו יכולים לדחוף אליו את הריפו המקומי שלנו, ומישהי אחרת יכולה למשוך אותו משם. 

בגיט זה מכונה `remote`. פעם אחת אנחנו מגדירים לגיט מה הרימוט שמולו עובד הריפו שלנו ומאז אנחנו יכולים לבקש ממנו למשוך (**fetch**) שינויים מהרימוט, לאחד את אותם שינויים עם הריפו שלנו (**merge**) ולדחוף לרימוט את השינויים המקומיים שלנו (**push**).

רימוט יכול להיות סתם שרת שאנחנו מרימים על כל מחשב, אבל יהיה לנו הרבה יותר קל לעבוד מול שירות ענן שמציע כבר את היכולת הזאת. הוא כנראה יהיה יותר יציב, יותר מהיר וגם אם אנחנו עובדים בקוד פתוח יהיה יותר קל למפתחים למצוא את הריפו שלנו בשירות מוכר.

הרבה חברות מציעות היום את השירות הזה, שתיים מהמפורסמות ביותר הן [GitLab]([https://gitlab.com](https://gitlab.com/)) ו [BitBucket](https://bitbucket.org) שמציעות גם תכניות בחינם.

אבל ללא כל ספק המלך הבלתי מעורער של שרתי גיט הוא [GitHub]([https://github.com](https://github.com/)). גיטהאב כמעט הפך לשם נרדף לגיט. 

נכון להיום מאוחסנים בגיטהאב יותר ממאה מיליון ריפוס! מתוכם לפחות 28 מיליון הם ציבוריים, כלומר פרוייקטים בקוד פתוח, ויש לכך סיבה טובה. גיטהאב מציעה אחסון חינם ללא כל הגבלה לפרוייקטים בקוד פתוח. כל מתכנת שמכבד את עצמו מחזיק חשבון בגיטהאב והרבה מאוד גם פרסמו לפחות פרוייקט אחד שם. בהרבה חברות יבקשו מכם קישור לדף הגיטהאב שלכם כדי לראות מה כתבתם, והאם פרסמתם משהו מעניין בקוד פתוח, זה יכול להגיד להם הרבה מאוד על סגנון כתיבת הקוד שלכם עוד לפני הראיון עצמו.

#### פתיחת חשבון בגיטהאב

אז קדימה, למה אנחנו מחכים? בואו נפתח חשבון בגיטהאב ונתחיל לדחוף קצת קוד.

אוקיי, פתחו את הכתובת הבאה https://github.com/join והשלימו את הרישום.

לאחר שתסיימו בהצלחה את הרישום ייפתח בפניכם דף שדומה לזה

![github](https://i.imgur.com/zNHSWnA.png)

זהו דף הגיטהאב האישי שלי (מחקתי פרוייקט פרטי של מקום עבודה קודם מהתמונה)

מצד שמאל תוכלו לראות רשימה חלקית של הריפוס שלי שמאוחסנים בגיטהאב.

אנחנו נלך ונלחץ על new בירוק למעלה משמאל

![new repo](https://i.imgur.com/pgqIViq.png)

ניתן לריפו שלנו שם ותיאור ונלחץ על create repository

כעת אנחנו צריכים לחבר בין הריפו המקומי שלנו לזה שיצרנו בגיטהאב.

למזלנו גיטהאב מספקים לנו את כל הפקודות שאנחנו צריכים כדי לעשות בדיוק את זה.

![gituhb add remote](https://i.imgur.com/dZlwIts.png)

אנחנו צריכים את האפשרות השלישית. יש לנו ריפו מקומי קיים, אנחנו רק רוצים להוסיף לו remote.

מעולה! אז נלחץ על כפתור העתק מצד ימין של האופציה הזאת.

נפתח את שורת הפקודה וננווט לתיקיית הריפו המקומית שלנו.

נדביק את הפקודות שהעתקנו מגיטהאב ונלחץ אנטר.

זו התשובה שאמורה להתקבל

```bash
Enumerating objects: 9, done.
Counting objects: 100% (9/9), done.
Delta compression using up to 8 threads
Compressing objects: 100% (3/3), done.
Writing objects: 100% (9/9), 714 bytes | 714.00 KiB/s, done.
Total 9 (delta 0), reused 0 (delta 0)
To https://github.com/orelzion/git_lesson_01.git
 * [new branch]      master -> master
Branch 'master' set up to track remote branch 'master' from 'origin'.
```

אוקיי נתעלם לרגע מכל הממבו ג׳מבו שגיט טורח לספר לנו עליו ונתחיל דווקא מהשורה האחרונה.

גיט מדווח לנו שהבראנץ׳ מאסטר המקומי שלנו, מכוון עכשיו לעבוד מול הבראנץ׳ מאסטר ברימוט. או במילים אחרות, יש לנו עותק של הבראנץ׳ המקומי שלנו בגיטהאב.

עכשיו בואו נחזור לדפדפן ונרפרש את העמוד (`ctrl + R` או `cmd + R` במק).

![new coed in github](https://i.imgur.com/FWLU6ly.png)

טא דם!

הקובץ שיצרנו נמצא בגיטהאב! 

גיטהאב מדווח לנו גם יותר מזה, הוא מציג לנו את רשימת הקומיטים שלנו, רשימת הבראנצ׳ים, וגם מי כתב את הקוד.

אגב הקונספט של בדיקה מי אחראי על הקומיט, קיבל את השם הלא מפתיע git blmae :)

<img src="https://img.devrant.com/devrant/rant/r_811491_uTXmv.jpg" alt="git blame" style="zoom:50%;" />

*image credit: https://devrant.com/rants/811491/git-blame-strikes-again*

טוב אז קודם סתם העתקנו את הפקודה שגיטהאב אמר לנו להעתיק כמו קופים, ולא ממש הבנו מה עשינו.

כמו שאנחנו רגילים, כדי להבין מה עשינו בואו נתחיל בלכתוב פקודות. 

כדי לדעת איזה רימוט מוגדר לנו בריפו נריץ את הפקודה

```bash
git remote -v
```

וזו התשובה שנקבל

```bash
origin	https://github.com/orelzion/git_lesson_01.git (fetch)
origin	https://github.com/orelzion/git_lesson_01.git (push)
```

גיט מציג לנו רשימה של שרתי רימוט שמוגדרים בריפו שלנו.

למה 2 אתם שואלים? אחד שממנו אנחנו מושכים (fetch) ואחד שאליו אנחנו דוחפים (push). במקרה שלנו (וברוב המקרים) זה אותו שרת.

לרימוט שלנו קוראים `origin`, כאשר נרצה לדחוף או למשוך שינויים נצטרך לומר לגיט מול איזה רימוט לבצע את הפקודה. 

באמצע מופיע ה `url` או הקישור לשרת הרימוט שלנו.

ועכשיו בואו נחזור וננסה להבין מה הייתה הפקודה שהעתקנו מגיטהאב.

#### git remote

הפקודה הראשונה שגיטהאב נתן לנו היא 

```bash
git remote add origin https://github.com/orelzion/git_lesson_01.git
```

בפקודה הזאת אנחנו בעצם מוסיפים רימוט לריפו שלנו. `git remote add` אומר למעשה ״הוסף רימוט״, `origin` הוא השם אותו בחרנו לרימוט. אחר כך יגיע ה`url`.

אנחנו יכולים להוסיף כמה רימוט שאנחנו רוצים, רק לזכור לתת להם שמות ייחודים להם. אבל בדרך כלל אין לנו צורך ביותר משרת רימוט אחד.

#### git push

אוקיי, הפקודה הבאה שגיט ביקש ממנו להוסיף היא 

```bash
git push -u origin master
```

גיט פוש זו הפקודה שדוחפת את השינויים המקומיים שלנו לשרת הרימוט. 

אז אנחנו אומרים לגיט לדחוף לרימוט `origin` את הבראנץ׳ `master`. 

ה`u-` אומר לגיט שאנחנו גם רוצים שהוא יזכור שזה הרימוט מולו אנחנו רוצים שמאסטר יעבוד תמיד, כך שפעם הבאה שנרצה לדחוף שינויים מהבראנץ׳ `master` לא נצטרך לרשום את כל הפקודה הארוכה הזאת, אלא רק `git push`. 

אבל זוכרים שיש לנו עוד בראנץ׳ מקומי? הרי יצרנו גם את `feature/git_branch_lesson` למה אנחנו לא רואים אותו בגיטהאב?

טוב, זה כי דחפנו רק את `master`, אז בואו נדחוף גם אותו.

זה אמור להיות קל, לא? חושבים שאתם יודעים איך לעשות את זה? בואו ננסה. נכתוב את הפקודה הבאה בשורת הפקודה.

```bash
git push -u origin feature/git_branch_lesson
```

ומה קיבלנו?

```bash
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Writing objects: 100% (3/3), 274 bytes | 274.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0)
remote: 
remote: Create a pull request for 'feature/git_branch_lesson' on GitHub by visiting:
remote:      https://github.com/orelzion/git_lesson_01/pull/new/feature/git_branch_lesson
remote: 
To https://github.com/orelzion/git_lesson_01.git
 * [new branch]      feature/git_branch_lesson -> feature/git_branch_lesson
```

יאיי! נראה שזה עבד!

נכון לעכשיו אני רוצה שנתרכז רק בשורות האחרונות

```
remote: 
To https://github.com/orelzion/git_lesson_01.git
 * [new branch]      feature/git_branch_lesson -> feature/git_branch_lesson
```

גיט יצר לנו בראנץ׳ חדש ברימוט, בדיוק כפי שביקשנו ממנו לעשות.

{{<subscribe text="אל תפספסו את החלק הבא!">}}

#### git fetch/pull

בואו נחזור רגע לגיטהאב.

![github edit](https://i.imgur.com/MCCJIV9.png)

נלחץ על כפתור העריכה שליד קובץ הREADME. זה יפתח לנו את חלון העריכה, שם נשנה את הטקסט ל `Second lesson in git`, כי וואלה נראה לי שכבר התקדמתם מספיק בשביל לקרוא לזה שיעור שני, לא?

![git edit window](https://i.imgur.com/bonHGZc.png)

עכשיו נגלול מטה ונעשה קומיט לשינוי שלנו. נכתוב הודעת קומיט מתאימה ונלחץ על `commit changes`

![github commit](https://i.imgur.com/vdbSz9z.png)

עכשיו בואו ונפתח את קובץ הREADME שנמצא על המחשב שלנו. 

שלא במפתיע, הטקסט שם עדיין יהיה `First lesson in git!! Yay`. 

אנחנו צריכים למשוך את השינויים מהרימוט.

בואו נפתח את שורת הפקודה ונכתוב את הפקודה הבאה

```bash
git fetch
```

זו התשובה שנקבל

```bash
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), done.
From https://github.com/orelzion/git_lesson_01
   c3ffefb..a899fae  master     -> origin/master
```

גיט מודיע לנו שהוא הוריד את השינויים שנעשו ב`origin/master` והם מוכנים להיכנס ל`master` המקומי שלנו. 

אם נפתח עכשיו את הקובץ המקומי שלנו, מה נראה בו?

```
First lesson in git!! Yay
```

למה ככה? כי גיט אמנם **משך** את השינויים מהבראנץ׳ ברימוט, אבל לא **איחד** אותם עם הבראנץ׳ המקומי.

כדי לאחד את השינויים מהרימוט למאסטר המקומי שלנו נריץ את הפקודה הבאה

```bash
git merge origin/master
```

אנחנו מבקשים מגיט לאחד (merge) את הבראנץ׳ המקומי שלנו עם `origin/master`.

וזו התשובה שנקבל

```bash
Updating c3ffefb..a899fae
Fast-forward
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
```

האיחוד הצליח! 

גיט מספר לנו שהוא מעדכן את הבראנץ׳ בעל ההאש הזה (אל תדאגו, זה הבראנץ׳ שלנו).

האיחוד התבצע כ`Fast-forward`, כלומר שלא היו שום בעיות לבצע את האיחוד הזה. במקרים מסויימים איחוד יכול להיכשל בעקבות קונפליקט, אנחנו נראה את זה בהמשך.

הקובץ שהתעדכן הוא `README.md` בו נעשו שני שינויים, מחיקה אחת והכנסה אחת.

קול! אתם אלופים!!

אבל למה אני צריך שתי קריאות? גם fetch וגם merge? גיט לא מבין שאם עשיתי fetch זה כדי שאוכל לאחד את השינויים שלי?

אז האמת היא שלא תמיד. לפעמים אתם עושים fetch רק כדי לקבל מידע, כמו למשל האם יש בראנצ׳ים חדשים ברימוט? האם יש קומיטים חדשים שמחכים שאאחד אותם? אבל אני לא בהכרח רוצה לאחד עכשיו כי עוד לא סיימתי לעבוד על השינוי שלי למשל.

אבל אם אתם ממש בטוחים שאתם רוצים לאחד את השינויים מהרימוט מיד, אתם יכולים במקום `git fetch` לקרוא ל`git pull` , פול עושה בעצם גם fetch וגם merge באותה פקודה.

## אז סיימנו?

לא ממש. למדנו הרבה בפרק הזה. אנחנו כבר ממש יכולים ליצור בראנצ׳ים, לעבור ביניהם, לשתף קוד עם אחרים ולקבל מהם שינויים.

אבל, עוד לא ממש למדנו איך לבצע `merge` אמיתי, כזה שכולל קונפליקטים. 

וגם, מי עדיין משתמש בשורת הפקודה? אתם בטח רוצים אפליקציה שיודעת לעשות את זה הדברים האלה בלחיצת כפתור.

אז, בפרק הבא נלמד איך לעבוד עם גיט באנדרואיד סטודיו, ואני גם אמליץ על [fork](https://git-fork.com/) אפליקציית גיט שאני מאוד נהנה לעבוד איתה.

נשתמע בפרק הבא, ובינתיים כתבו בתגובות איך היה